<!DOCTYPE html>
<html>
<head>
    <title>Molecule Viewer</title>
    <style>
        body { margin: 0; font-family: sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <label for="style-selector">Style</label>
            <select id="style-selector">
                <option value="default">Default</option>
                <option value="2d">2D</option>
                <option value="cartoon">Cartoon</option>
                <option value="neon">Neon</option>
                <option value="glossy">Glossy</option>
                <option value="metallic">Metallic</option>
                <option value="rowan">Rowan</option>
                <option value="grey">Grey</option>
            </select>
        </div>
        <div class="control-group">
            <label for="control-type">Controls</label>
            <select id="control-type">
                <option value="orbit">Orbit</option>
                <option value="trackball">Trackball</option>
            </select>
        </div>
        <div class="control-group">
            <label for="camera-mode">Camera</label>
            <select id="camera-mode">
                <option value="perspective">Perspective</option>
                <option value="orthographic">Orthographic</option>
            </select>
        </div>
        <div class="control-group">
            <label for="atom-scale">Atom Scale: <span id="atom-scale-value">0.5</span></label>
            <input type="range" id="atom-scale" min="0.1" max="2" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label for="bond-scale">Bond Scale: <span id="bond-scale-value">0.1</span></label>
            <input type="range" id="bond-scale" min="0.05" max="0.5" step="0.01" value="0.1">
        </div>
        <div class="control-group">
            <label for="bond-cutoff-scale">Bond Cutoff Scale: <span id="bond-cutoff-scale-value">1.0</span></label>
            <input type="range" id="bond-cutoff-scale" min="0.5" max="1.5" step="0.05" value="1.0">
        </div>
        <div class="control-group">
            <label for="force-scale">Force Vector Scale: <span id="force-scale-value">0.5</span></label>
            <input type="range" id="force-scale" min="0.1" max="2" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label for="bg-color">Background Color</label>
            <input type="color" id="bg-color" value="#000000">
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TrackballControls.js"></script>
    <script src="js/styles.js"></script>
    <script>
        let scene, camera, renderer, controls, light;
        let molecule;
        
        // --- Control State Variables ---
        let currentStyle = 'default';
        let controlType = 'orbit';
        let cameraMode = 'perspective';
        let atomScale = 0.5;
        let bondScale = 0.1;
        let bondCutoffScale = 1.0;
        let forceVectorScale = 0.5;
        let bgColor = 0x000000;

        const benz_data = {"positions": [[-2.815143, -0.036852499999999955, 2.0849254999999998], [-3.2998790000000002, 0.22488850000000005, 0.6976125], [-4.474348000000001, 0.7332635000000001, 0.3704224999999999], [-5.263804, 1.0327635000000002, 1.0289335], [-4.674386, 0.8245415, -1.3996515], [-5.596795, -0.1812855, -1.8429985], [-4.902205, 2.1734725, -1.8354785], [-2.949687, 0.3242585, -1.7652815000000002], [-2.395527, -0.15964949999999994, -0.4424785000000001], [-2.2496400000000003, -1.2510715, -0.44695750000000006], [-0.7039850000000002, 0.49565250000000005, -0.15830050000000007], [0.30764799999999987, -0.8659215, -0.7251775], [1.63299, -0.6624815, -0.6829425000000001], [2.477477, -1.7101195, -1.2243895], [2.386891, -2.6128465, -0.6149245000000001], [2.140002, -1.9657904999999998, -2.2315325], [3.517266, -1.4051505, -1.2621195], [2.1958349999999998, 0.5722135, -0.16276950000000012], [3.5590569999999997, 0.3928395, 0.4757445], [3.731591, 1.1337485, 1.2498495], [3.742555, -0.6027494999999999, 0.8632115], [4.7694399999999995, 0.7668475, -0.8590735], [5.596795, 1.8616465, -0.44871250000000007], [5.423902999999999, -0.4392045, -1.2887145000000002], [3.555382, 1.3216455, -2.1082125], [2.344407, 1.6465555, -1.2652055], [2.4877219999999998, 2.6128465, -0.7800565], [1.4317229999999999, 1.6939065, -1.8595575], [3.3919509999999997, 0.5054745, -2.8041834999999997], [3.967538, 2.1833275, -2.6205985], [1.4870599999999998, 0.9441985, 0.5871795], [-0.35322200000000015, -2.2660025, -1.2749925000000002], [-2.4491530000000004, 1.2182345, -2.1271915000000003], [-2.956604, -0.44523749999999995, -2.5305355], [-3.6147270000000002, 0.10990550000000003, 2.8041834999999997], [-2.4415440000000004, -1.0564735, 2.1644185], [-1.99544, 0.6387465000000001, 2.3269954999999998]], "symbols": ["C", "C", "C", "H", "S", "O", "O", "C", "C", "H", "S", "C", "N", "C", "H", "H", "H", "C", "C", "H", "H", "S", "O", "O", "C", "C", "H", "H", "H", "H", "H", "S", "H", "H", "H", "H", "H"], "cell": [[7.1587541522, 0.0, 0.0], [0.0, 6.423423423400001, 0.0], [0.0, 0.0, 8.2342342342]], "forces": [[0.1, 0.2, -0.1], [-0.1, -0.2, 0.1], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]}

        function init() {
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            renderer.sortObjects = true; // Explicitly enable object sorting

            setupCamera();
            setupControls();

            light = new THREE.DirectionalLight(0xffffff, 0.8);
            scene.add(light);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            
            scene.background = new THREE.Color(bgColor);

            drawMolecule();
            animate();
        }

        function setupCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            if (cameraMode === 'perspective') {
                camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            } else { // orthographic
                const frustumSize = 10;
                camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            }
            camera.position.z = 5;
        }

        function setupControls() {
            if (controls) {
                controls.dispose();
            }
            if (controlType === 'orbit') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
            } else { // trackball
                controls = new THREE.TrackballControls(camera, renderer.domElement);
                controls.rotateSpeed = 5.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
            }
        }

        function drawMolecule() {
            if (molecule) {
                scene.remove(molecule);
            }
            molecule = new THREE.Group();

            const positions = benz_data.positions.map(p => new THREE.Vector3(...p));
            const symbols = benz_data.symbols;

            const uniqueSymbols = [...new Set(symbols)];
            const greyColorMap = {};
            for (let i = 0; i < uniqueSymbols.length; i++) {
                const lightness = (i + 1) / (uniqueSymbols.length + 1);
                greyColorMap[uniqueSymbols[i]] = new THREE.Color().setHSL(0, 0, lightness);
            }

            // Draw Forces
            if (benz_data.forces) {
                const forceColor = 0xff0000;
                const headLength = 0.2;
                const headWidth = 0.1;
                for (let i = 0; i < positions.length; i++) {
                    const forceVec = new THREE.Vector3(...benz_data.forces[i]);
                    if (forceVec.lengthSq() === 0) continue;
                    const origin = positions[i];
                    const direction = forceVec.clone().normalize();
                    const length = forceVec.length() * forceVectorScale;
                    const arrowHelper = new THREE.ArrowHelper(direction, origin, length, forceColor, headLength, headWidth);
                    arrowHelper.renderOrder = 3; // Forces last
                    molecule.add(arrowHelper);
                }
            }

            // Draw Cell
            if (benz_data.cell) {
                const cellMaterial = new THREE.LineBasicMaterial({ color: 0x808080 });
                const cellVectors = benz_data.cell.map(c => new THREE.Vector3(...c));
                const points = [
                    new THREE.Vector3(0,0,0), cellVectors[0],
                    new THREE.Vector3(0,0,0), cellVectors[1],
                    new THREE.Vector3(0,0,0), cellVectors[2],
                    cellVectors[0], cellVectors[0].clone().add(cellVectors[1]),
                    cellVectors[0], cellVectors[0].clone().add(cellVectors[2]),
                    cellVectors[1], cellVectors[1].clone().add(cellVectors[0]),
                    cellVectors[1], cellVectors[1].clone().add(cellVectors[2]),
                    cellVectors[2], cellVectors[2].clone().add(cellVectors[0]),
                    cellVectors[2], cellVectors[2].clone().add(cellVectors[1]),
                    cellVectors[0].clone().add(cellVectors[1]), cellVectors[0].clone().add(cellVectors[1]).add(cellVectors[2]),
                    cellVectors[0].clone().add(cellVectors[2]), cellVectors[0].clone().add(cellVectors[1]).add(cellVectors[2]),
                    cellVectors[1].clone().add(cellVectors[2]), cellVectors[0].clone().add(cellVectors[1]).add(cellVectors[2]),
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMesh = new THREE.LineSegments(geometry, cellMaterial);
                lineMesh.renderOrder = 2; // Cell after bonds
                molecule.add(lineMesh);
            }

            // Draw Bonds
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    const dist = positions[i].distanceTo(positions[j]);
                    if (dist < 1.6 * bondCutoffScale) {
                        let bond;
                        switch (currentStyle) {
                            case '2d': bond = createBondStyle2D(positions[i], positions[j], symbols[i], symbols[j], bondScale, atomScale); break;
                            case 'cartoon': bond = createBondStyleCartoon(positions[i], positions[j], symbols[i], symbols[j], bondScale, atomScale); break;
                            case 'neon': bond = createBondStyleNeon(positions[i], positions[j], symbols[i], symbols[j], bondScale, atomScale); break;
                            case 'rowan': bond = createBondStyleRowan(positions[i], positions[j], symbols[i], symbols[j], bondScale, atomScale); break;
                            case 'grey': bond = createBondStyleGrey(positions[i], positions[j], symbols[i], symbols[j], bondScale, atomScale, greyColorMap); break;
                            default: bond = createBondStyleDefault(positions[i], positions[j], symbols[i], symbols[j], bondScale, atomScale, currentStyle); break;
                        }
                        if (bond) {
                            bond.renderOrder = 1; // Bonds after atoms
                            molecule.add(bond);
                        }
                    }
                }
            }

            // Draw Atoms
            for (let i = 0; i < positions.length; i++) {
                let atom;
                switch (currentStyle) {
                    case '2d': atom = createAtomStyle2D(positions[i], symbols[i], atomScale); break;
                    case 'cartoon': atom = createAtomStyleCartoon(positions[i], symbols[i], atomScale); break;
                    case 'neon': atom = createAtomStyleNeon(positions[i], symbols[i], atomScale); break;
                    case 'glossy': atom = createAtomStyleGlossy(positions[i], symbols[i], atomScale); break;
                    case 'metallic': atom = createAtomStyleMetallic(positions[i], symbols[i], atomScale); break;
                    case 'rowan': atom = createAtomStyleRowan(positions[i], symbols[i], atomScale); break;
                    case 'grey': atom = createAtomStyleGrey(positions[i], symbols[i], atomScale, greyColorMap[symbols[i]]); break;
                    default: atom = createAtomStyleDefault(positions[i], symbols[i], atomScale); break;
                }
                atom.renderOrder = 0; // Atoms first
                molecule.add(atom);
            }
            scene.add(molecule);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            light.position.copy(camera.position);
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        document.getElementById('style-selector').addEventListener('change', (event) => {
            currentStyle = event.target.value;
            drawMolecule();
        });

        document.getElementById('control-type').addEventListener('change', (event) => {
            controlType = event.target.value;
            setupControls();
        });

        document.getElementById('camera-mode').addEventListener('change', (event) => {
            cameraMode = event.target.value;
            const oldPos = camera.position.clone();
            const oldZoom = camera.zoom;
            setupCamera();
            camera.position.copy(oldPos);
            camera.zoom = oldZoom;
            camera.updateProjectionMatrix();
            setupControls();
        });

        document.getElementById('atom-scale').addEventListener('input', (event) => {
            atomScale = parseFloat(event.target.value);
            document.getElementById('atom-scale-value').textContent = atomScale.toFixed(2);
            drawMolecule();
        });

        document.getElementById('bond-scale').addEventListener('input', (event) => {
            bondScale = parseFloat(event.target.value);
            document.getElementById('bond-scale-value').textContent = bondScale.toFixed(2);
            drawMolecule();
        });

        document.getElementById('bond-cutoff-scale').addEventListener('input', (event) => {
            bondCutoffScale = parseFloat(event.target.value);
            document.getElementById('bond-cutoff-scale-value').textContent = bondCutoffScale.toFixed(2);
            drawMolecule();
        });
        
        document.getElementById('force-scale').addEventListener('input', (event) => {
            forceVectorScale = parseFloat(event.target.value);
            document.getElementById('force-scale-value').textContent = forceVectorScale.toFixed(2);
            drawMolecule();
        });

        document.getElementById('bg-color').addEventListener('input', (event) => {
            bgColor = parseInt(event.target.value.replace('#', ''), 16);
            scene.background = new THREE.Color(bgColor);
        });

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            if (camera.isPerspectiveCamera) {
                camera.aspect = aspect;
            } else { // isOrthographicCamera
                const frustumSize = 10;
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
            }
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (controls.handleResize) controls.handleResize();
        }, false);

        init();
    </script>
</body>
</html>
