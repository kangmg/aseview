<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molecular Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TrackballControls.js"></script>
    <script src="https://raw.githack.com/kangmg/aseview/main/aseview/static/js/styles.js"></script>
    <style>
        :root {
            --sidebar-bg: #1f2937;
            --card-bg: #374151;
            --border-color: #4b5563;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --accent-color: #3b82f6;
            --hover-color: #4b5563;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #111827;
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: hidden;
            flex-shrink: 0;
        }

        .sidebar.collapsed {
            width: 0;
            border-right: none;
            overflow: hidden;
        }

        .sidebar-content {
            padding: 1rem;
            overflow-y: auto;
            flex: 1;
        }

        .sidebar-toggle {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 100;
            background-color: rgba(31, 41, 55, 0.9);
            border: none;
            border-radius: 0.5rem;
            color: var(--text-primary);
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Cards */
        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .card-header {
            padding: 0.75rem 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .card-header h3 {
            font-size: 0.875rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-content {
            padding: 1rem;
        }

        .card-content.collapsed {
            display: none;
        }

        /* Controls */
        .control-group {
            margin-bottom: 1rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }

        .slider-value {
            font-size: 0.75rem;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: right;
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .color-input {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
        }

        .color-value {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .select {
            width: 100%;
            background-color: var(--hover-color);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            color: var(--text-primary);
            padding: 0.5rem;
            font-size: 0.875rem;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: .4s;
            border-radius: 20px;
        }

        .slider-switch:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider-switch {
            background-color: var(--accent-color);
        }

        input:checked + .slider-switch:before {
            transform: translateX(20px);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .btn {
            background-color: var(--hover-color);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .btn.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .btn:hover {
            background-color: rgba(59, 130, 246, 0.2);
            color: var(--text-primary);
        }

        /* Periodicity controls */
        .periodicity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--hover-color);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .periodicity-item:last-child {
            margin-bottom: 0;
        }

        /* Main content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 0;
            width: 100%;
        }

        .toolbar {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 10;
        }

        .toolbar-btn {
            background-color: rgba(31, 41, 55, 0.9);
            border: none;
            border-radius: 0.5rem;
            color: var(--text-primary);
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Animation control buttons */
        .animation-btn-group {
            display: flex;
            gap: 6px;
            margin-bottom: 1rem;
        }

        .anim-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            background-color: var(--hover-color);
            color: var(--text-secondary);
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .anim-btn:hover {
            background-color: var(--border-color);
        }

        .anim-btn:active {
            background-color: var(--card-bg);
        }

        .anim-btn svg {
            width: 18px;
            height: 18px;
        }

        .anim-btn.playing {
            background-color: #5e81ac;
            color: #eceff4;
        }

        .viewer-container {
            flex: 1;
            display: flex;
            background: linear-gradient(135deg, #1f2937, #111827);
            position: relative;
            min-height: 0;
            width: 100%;
        }

        .viewer {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        /* Molecular visualization */
        #molecule-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
            position: absolute;
            top: 0;
            left: 0;
        }

        #molecule-canvas:active {
            cursor: grabbing;
        }

        /* Icons */
        .icon {
            width: 16px;
            height: 16px;
            display: inline-block;
        }

        /* Animation */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Help text */
        .help-text {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #9CA3AF;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <!-- Advanced Settings -->
                <div class="card">
                    <div class="card-header" onclick="toggleCard('advanced')">
                        <h3>
                            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            Advanced Settings
                        </h3>
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" id="advanced-arrow">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="card-content" id="advanced-content">
                        <div class="control-group">
                            <div class="control-label">
                                <span>Bond Threshold Scale</span>
                                <span class="slider-value" id="bond-threshold-value">1.0</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.5" max="3" step="0.1" value="1.0" class="slider" id="bond-threshold">
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Bond Thickness</span>
                                <span class="slider-value" id="bond-thickness-value">0.10</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.05" max="0.5" step="0.01" value="0.1" class="slider" id="bond-thickness">
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Atom Size</span>
                                <span class="slider-value" id="atom-size-value">0.4×</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.1" max="2" step="0.1" value="0.4" class="slider" id="atom-size">
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Animation Speed (FPS)</span>
                                <span class="slider-value" id="animation-speed-value">30</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="1" max="60" step="1" value="30" class="slider" id="animation-speed">
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Force Scale</span>
                                <span class="slider-value" id="force-scale-value">0.5×</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.1" max="5" step="0.1" value="0.5" class="slider" id="force-scale">
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Background Color</span>
                            </div>
                            <div class="color-picker">
                                <input type="color" value="#1f2937" class="color-input" id="background-color">
                                <span class="color-value" id="background-color-value">#1f2937</span>
                            </div>
                        </div>

                        <div class="control-group" id="cell-color-group" style="display: none;">
                            <div class="control-label">
                                <span>Cell Color</span>
                            </div>
                            <div class="color-picker">
                                <input type="color" value="#808080" class="color-input" id="cell-color">
                                <span class="color-value" id="cell-color-value">#808080</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Style</span>
                            </div>
                            <select class="select" id="style">
                                <option value="default">Default</option>
                                <option value="2d">2D</option>
                                <option value="cartoon" selected>Cartoon</option>
                                <option value="neon">Neon</option>
                                <option value="glossy">Glossy</option>
                                <option value="metallic">Metallic</option>
                                <option value="bubble">Bubble</option>
                                <option value="rowan">Rowan</option>
                                <option value="grey">Grey</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Display Settings -->
                <div class="card">
                    <div class="card-header" onclick="toggleCard('display')">
                        <h3>
                            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                            </svg>
                            Display Settings
                        </h3>
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" id="display-arrow">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="card-content" id="display-content">
                        <div class="control-group">
                            <div class="control-label">
                                <span>Cell</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-cell" checked>
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Bond</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-bond" checked>
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Shading</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-shading">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Energy Plot</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-energy-plot">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Forces</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-forces">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Axis</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-axis" checked>
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <!-- Color By section - only visible when charges are present -->
                        <div class="control-group" id="color-by-section" style="display: none;">
                            <div class="control-label">
                                <span>Color By</span>
                            </div>
                            <select class="select" id="color-by-select">
                                <option value="Element">Element</option>
                                <option value="Charge">Charge</option>
                            </select>
                        </div>

                        <!-- Normalize Charges toggle - only visible when colorBy is Charge -->
                        <div class="control-group" id="normalize-charges-section" style="display: none;">
                            <div class="control-label">
                                <span>Normalize</span>
                                <label class="switch">
                                    <input type="checkbox" id="normalize-charges">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <!-- Show Charge Labels toggle - only visible when colorBy is Charge -->
                        <div class="control-group" id="show-charge-labels-section" style="display: none;">
                            <div class="control-label">
                                <span>Show Labels</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-charge-labels">
                                    <span class="slider-switch"></span>
                                </label>
                            </div>
                        </div>

                        <!-- Color bar for charge scale -->
                        <div class="control-group" id="charge-colorbar-section" style="display: none;">
                            <div style="width: 100%; padding: 0.25rem 0;">
                                <div id="charge-colorbar" style="height: 12px; border-radius: 6px; background: linear-gradient(90deg, #b40426 0%, #f7f7f7 50%, #3b4cc0 100%);"></div>
                                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #9ca3af; margin-top: 2px;">
                                    <span id="charge-min">-1.0</span>
                                    <span>0</span>
                                    <span id="charge-max">+1.0</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>View Mode</span>
                            </div>
                            <div class="button-group">
                                <button class="btn" id="orthographic-btn">
                                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
                                    </svg>
                                    Orthographic
                                </button>
                                <button class="btn active" id="perspective-btn">
                                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 22V12h6v10" />
                                    </svg>
                                    Perspective
                                </button>
                            </div>
                        </div>

                        <!-- Add Periodicity -->
                        <div class="control-group">
                            <div class="control-label">
                                <span>Add Periodicity</span>
                            </div>
                            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <select class="select" id="periodicity-select" style="flex: 1;">
                                    <option value="+x">+x</option>
                                    <option value="+y">+y</option>
                                    <option value="+z">+z</option>
                                    <option value="±x">±x</option>
                                    <option value="±y">±y</option>
                                    <option value="±z">±z</option>
                                </select>
                                <button class="btn" id="add-periodicity-btn" style="padding: 0.5rem; min-width: 40px;">
                                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Added Periodicities -->
                        <div class="control-group" id="periodicities-container">
                            <div class="control-label">
                                <span>Periodicities</span>
                            </div>
                            <div id="periodicities-list">
                                <!-- Periodicity items will be added here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Interaction Settings -->
                <div class="card">
                    <div class="card-header" onclick="toggleCard('interaction')">
                        <h3>
                            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" />
                            </svg>
                            Interaction Settings
                        </h3>
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" id="interaction-arrow">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="card-content" id="interaction-content">
                        <div class="control-group">
                            <div class="control-label">
                                <span>Rotation Mode</span>
                            </div>
                            <div class="button-group">
                                <button class="btn active" id="trackball-btn">
                                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
                                    </svg>
                                    TrackBall
                                </button>
                                <button class="btn" id="orbit-btn">
                                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 22V12h6v10" />
                                    </svg>
                                    Orbit
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Animation -->
                <div class="card">
                    <div class="card-header">
                        <h3>
                            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            Animation
                        </h3>
                    </div>
                    <div class="card-content">
                        <div class="animation-btn-group">
                            <button class="anim-btn" id="play-btn" title="Play/Pause">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                                </svg>
                            </button>
                            <button class="anim-btn" id="copy-btn" title="Copy current frame">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                </svg>
                            </button>
                            <button class="anim-btn" id="copy-all-btn" title="Copy all frames">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                </svg>
                            </button>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Frame</span>
                                <span class="slider-value" id="frame-value">1 / 100</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="1" max="100" step="1" value="1" class="slider" id="frame-slider">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
            <button class="sidebar-toggle" id="sidebar-toggle">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>

            <div class="toolbar">
                <button class="toolbar-btn" id="video-btn">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                </button>
                <button class="toolbar-btn" id="download-btn">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                </button>
            </div>

            <div class="viewer-container">
                <div class="viewer" id="viewer">
                    <canvas id="molecule-canvas"></canvas>
                </div>
                <!-- Energy Plot -->
                <div class="energy-plot-container" id="energy-plot-container" style="display: none;">
                    <div class="energy-plot-resize-handle" id="energy-plot-resize-handle"></div>
                    <canvas id="energy-plot-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <style>
        .energy-plot-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 120px;
            min-height: 80px;
            max-height: 400px;
            background: rgba(31, 41, 55, 0.9);
            border-radius: 8px;
            padding: 10px;
            padding-top: 18px;
            box-sizing: border-box;
        }
        .energy-plot-resize-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 18px;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px 8px 0 0;
        }
        .energy-plot-resize-handle::after {
            content: '';
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        .energy-plot-resize-handle:hover::after {
            background: rgba(255, 255, 255, 0.5);
        }
        #energy-plot-canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script>
        
// Global variables
let molecularData = [];
let sidebarOpen = true;
let cards = {
    advanced: true,
    display: true,
    interaction: true
};

let periodicities = [];

// File naming for downloads
let downloadBaseName = 'molecule';  // Can be set via setDownloadName()
let downloadCounters = { png: 0, gif: 0 };  // Track download counts

let settings = {
    bondThreshold: 1.0,
    bondThickness: 0.1,
    atomSize: 0.4,
    animationSpeed: 30,
    forceScale: 0.5,
    backgroundColor: '#1f2937',
    cellColor: '#808080',
    style: 'cartoon',
    showCell: true,
    showBond: true,
    showShading: true,
    showEnergyPlot: false,
    showForces: false,
    showAxis: true,
    colorBy: 'Element',  // 'Element' or 'Charge'
    normalizeCharges: false,
    showChargeLabels: false,
    chargeColormap: 'coolwarm',
    viewMode: 'Perspective',
    rotationMode: 'TrackBall'
};

// Update UI and rendering from settings (called via postMessage API)
function updateFromSettings() {
    // Update select elements
    const styleSelect = document.getElementById('style');
    if (styleSelect) styleSelect.value = settings.style || 'cartoon';

    const colorBySelect = document.getElementById('color-by-select');
    if (colorBySelect) colorBySelect.value = settings.colorBy || 'Element';

    // Update checkboxes
    const checkboxMappings = {
        'show-cell': 'showCell',
        'show-bond': 'showBond',
        'show-shading': 'showShading',
        'show-energy-plot': 'showEnergyPlot',
        'show-forces': 'showForces',
        'show-axis': 'showAxis',
        'normalize-charges': 'normalizeCharges',
        'show-charge-labels': 'showChargeLabels'
    };

    for (const [elemId, settingKey] of Object.entries(checkboxMappings)) {
        const elem = document.getElementById(elemId);
        if (elem) elem.checked = !!settings[settingKey];
    }

    // Update sliders
    const atomSizeSlider = document.getElementById('atom-size');
    if (atomSizeSlider) {
        atomSizeSlider.value = settings.atomSize || 0.4;
        const valueEl = document.getElementById('atom-size-value');
        if (valueEl) valueEl.textContent = atomSizeSlider.value;
    }

    const bondThresholdSlider = document.getElementById('bond-threshold');
    if (bondThresholdSlider) {
        bondThresholdSlider.value = settings.bondThreshold || 1.0;
        const valueEl = document.getElementById('bond-threshold-value');
        if (valueEl) valueEl.textContent = bondThresholdSlider.value;
    }

    const bondThicknessSlider = document.getElementById('bond-thickness');
    if (bondThicknessSlider) {
        bondThicknessSlider.value = settings.bondThickness || 0.1;
        const valueEl = document.getElementById('bond-thickness-value');
        if (valueEl) valueEl.textContent = bondThicknessSlider.value;
    }

    const animSpeedSlider = document.getElementById('animation-speed');
    if (animSpeedSlider) {
        animSpeedSlider.value = settings.animationSpeed || 30;
        const valueEl = document.getElementById('animation-speed-value');
        if (valueEl) valueEl.textContent = animSpeedSlider.value;
    }

    const forceScaleSlider = document.getElementById('force-scale');
    if (forceScaleSlider) {
        forceScaleSlider.value = settings.forceScale || 0.5;
        const valueEl = document.getElementById('force-scale-value');
        if (valueEl) valueEl.textContent = forceScaleSlider.value;
    }

    // Update color pickers
    const bgColorPicker = document.getElementById('background-color');
    if (bgColorPicker && settings.backgroundColor) {
        bgColorPicker.value = settings.backgroundColor;
        const viewerContainer = document.querySelector('.viewer-container');
        if (viewerContainer) {
            viewerContainer.style.background = `linear-gradient(135deg, ${settings.backgroundColor}, ${darkenColorHex(settings.backgroundColor, 20)})`;
        }
    }

    const cellColorPicker = document.getElementById('cell-color');
    if (cellColorPicker && settings.cellColor) {
        cellColorPicker.value = settings.cellColor;
        const valueEl = document.getElementById('cell-color-value');
        if (valueEl) valueEl.textContent = settings.cellColor;
    }

    // Update energy plot visibility
    const plotContainer = document.getElementById('energy-plot-container');
    if (plotContainer) {
        plotContainer.style.display = settings.showEnergyPlot ? 'block' : 'none';
    }

    // Apply rendering changes
    if (typeof updateShading === 'function') updateShading();
    if (typeof updateChargeUI === 'function') updateChargeUI();
    if (typeof renderMolecule === 'function') renderMolecule();
}

// Check if styles.js is loaded
if (typeof atomInfo === 'undefined') {
    console.error('styles.js not loaded! atomInfo is undefined');
}
if (typeof createAtomStyleDefault === 'undefined') {
    console.error('styles.js not loaded! createAtomStyleDefault is undefined');
}

const atomFactories = {
    'default': (pos, symbol, atomScale) => createAtomStyleDefault(pos, symbol, atomScale),
    '2d': (pos, symbol, atomScale) => createAtomStyle2D(pos, symbol, atomScale),
    'cartoon': (pos, symbol, atomScale) => createAtomStyleCartoon(pos, symbol, atomScale),
    'neon': (pos, symbol, atomScale) => createAtomStyleNeon(pos, symbol, atomScale),
    'glossy': (pos, symbol, atomScale) => createAtomStyleGlossy(pos, symbol, atomScale),
    'metallic': (pos, symbol, atomScale) => createAtomStyleMetallic(pos, symbol, atomScale),
    'rowan': (pos, symbol, atomScale) => createAtomStyleRowan(pos, symbol, atomScale),
    'bubble': (pos, symbol, atomScale) => createAtomStyleBubble(pos, symbol, atomScale),
    'grey': (pos, symbol, atomScale, helpers) => createAtomStyleGrey(pos, symbol, atomScale, helpers.greyColorMap[symbol] ?? 0x808080)
};

const bondFactories = {
    'default': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleDefault(p1, p2, sym1, sym2, bondRadius, atomScale, 'default'),
    '2d': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyle2D(p1, p2, sym1, sym2, bondRadius, atomScale),
    'cartoon': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleCartoon(p1, p2, sym1, sym2, bondRadius, atomScale),
    'neon': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleNeon(p1, p2, sym1, sym2, bondRadius, atomScale),
    'glossy': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleDefault(p1, p2, sym1, sym2, bondRadius, atomScale, 'glossy'),
    'metallic': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleDefault(p1, p2, sym1, sym2, bondRadius, atomScale, 'metallic'),
    'rowan': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleRowan(p1, p2, sym1, sym2, bondRadius, atomScale),
    'bubble': (p1, p2, sym1, sym2, bondRadius, atomScale) => createBondStyleBubble(p1, p2, sym1, sym2, bondRadius, atomScale),
    'grey': (p1, p2, sym1, sym2, bondRadius, atomScale, helpers) => createBondStyleGrey(p1, p2, sym1, sym2, bondRadius, atomScale, helpers.greyColorMap)
};

// Charge coloring utilities
let chargeStats = { hasCharges: false, min: 0, max: 0, maxPositive: 0, minNegative: 0 };

function checkChargesInData() {
    if (!molecularData || molecularData.length === 0) return false;

    let hasCharges = false;
    let allCharges = [];

    for (const frame of molecularData) {
        if (frame.charges && Array.isArray(frame.charges) && frame.charges.length > 0) {
            hasCharges = true;
            allCharges = allCharges.concat(frame.charges);
        }
    }

    if (hasCharges && allCharges.length > 0) {
        chargeStats.hasCharges = true;
        chargeStats.min = Math.min(...allCharges);
        chargeStats.max = Math.max(...allCharges);
        chargeStats.absMax = Math.max(Math.abs(chargeStats.min), Math.abs(chargeStats.max));
        // Track positive and negative ranges separately
        const positiveCharges = allCharges.filter(c => c > 0);
        const negativeCharges = allCharges.filter(c => c < 0);
        chargeStats.maxPositive = positiveCharges.length > 0 ? Math.max(...positiveCharges) : 0;
        chargeStats.minNegative = negativeCharges.length > 0 ? Math.min(...negativeCharges) : 0;
    } else {
        chargeStats.hasCharges = false;
    }

    return hasCharges;
}

function updateChargeUI() {
    const colorBySection = document.getElementById('color-by-section');
    const normalizeSection = document.getElementById('normalize-charges-section');
    const labelsSection = document.getElementById('show-charge-labels-section');
    const colorbarSection = document.getElementById('charge-colorbar-section');

    if (!colorBySection) return;

    if (chargeStats.hasCharges) {
        colorBySection.style.display = 'block';

        // Show options only when colorBy is 'Charge'
        const showChargeOptions = settings.colorBy === 'Charge';
        if (normalizeSection) normalizeSection.style.display = showChargeOptions ? 'block' : 'none';
        if (labelsSection) labelsSection.style.display = showChargeOptions ? 'block' : 'none';
        if (colorbarSection) colorbarSection.style.display = showChargeOptions ? 'block' : 'none';

        // Update colorbar labels
        if (showChargeOptions) {
            updateColorbarLabels();
        }
    } else {
        colorBySection.style.display = 'none';
        if (normalizeSection) normalizeSection.style.display = 'none';
        if (labelsSection) labelsSection.style.display = 'none';
        if (colorbarSection) colorbarSection.style.display = 'none';
    }
}

function updateColorbarLabels() {
    const minLabel = document.getElementById('charge-min');
    const maxLabel = document.getElementById('charge-max');

    if (!minLabel || !maxLabel) return;

    let minVal, maxVal;
    if (settings.normalizeCharges) {
        // Normalize mode: show -1.0 to +1.0 (full range used)
        minVal = -1.0;
        maxVal = 1.0;
    } else {
        // Non-normalize mode: show symmetric range based on absMax
        const absMax = chargeStats.absMax || 1.0;
        minVal = -absMax;
        maxVal = absMax;
    }

    minLabel.textContent = minVal.toFixed(2);
    maxLabel.textContent = (maxVal > 0 ? '+' : '') + maxVal.toFixed(2);
}

// Coolwarm colormap: red (negative) -> white (zero) -> blue (positive)
function getChargeColor(charge, normalize = false) {
    // Standard convention: red = negative, blue = positive
    const negativeColor = new THREE.Color(0xb40426);  // Red
    const neutralColor = new THREE.Color(0xf7f7f7);   // White
    const positiveColor = new THREE.Color(0x3b4cc0);  // Blue

    let resultColor = new THREE.Color();
    let t;

    if (normalize) {
        // Normalize: scale each direction to its max (full color range)
        if (charge >= 0) {
            const maxPos = chargeStats.maxPositive || 1.0;
            t = maxPos > 0 ? Math.min(charge / maxPos, 1) : 0;
            resultColor.lerpColors(neutralColor, positiveColor, t);
        } else {
            const minNeg = chargeStats.minNegative || -1.0;
            t = minNeg < 0 ? Math.min(Math.abs(charge) / Math.abs(minNeg), 1) : 0;
            resultColor.lerpColors(neutralColor, negativeColor, t);
        }
    } else {
        // Non-normalize: use symmetric range based on absMax
        const absMax = chargeStats.absMax || 1.0;
        if (charge >= 0) {
            t = absMax > 0 ? Math.min(charge / absMax, 1) : 0;
            resultColor.lerpColors(neutralColor, positiveColor, t);
        } else {
            t = absMax > 0 ? Math.min(Math.abs(charge) / absMax, 1) : 0;
            resultColor.lerpColors(neutralColor, negativeColor, t);
        }
    }

    return resultColor.getHex();
}

// Create atom with custom color (for charge coloring)
function createAtomWithColor(pos, symbol, atomScale, colorHex, styleName) {
    const info = atomInfo[symbol] || atomInfo['default'];
    const scaledRadius = info.radius * atomScale;

    // Create geometry based on style
    let geometry, material, mesh;

    switch (styleName) {
        case 'neon':
            geometry = new THREE.SphereGeometry(scaledRadius, 32, 32);
            material = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.9
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);

            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(scaledRadius * 1.3, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(pos);

            const group = new THREE.Group();
            group.add(glow);
            group.add(mesh);
            return group;

        case 'glossy':
            geometry = new THREE.SphereGeometry(scaledRadius, 32, 32);
            material = new THREE.MeshPhongMaterial({
                color: colorHex,
                specular: 0x444444,
                shininess: 100
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            return mesh;

        case 'metallic':
            geometry = new THREE.SphereGeometry(scaledRadius, 32, 32);
            material = new THREE.MeshStandardMaterial({
                color: colorHex,
                metalness: 0.8,
                roughness: 0.2
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            return mesh;

        default:  // cartoon, default, etc.
            geometry = new THREE.SphereGeometry(scaledRadius, 32, 32);
            material = new THREE.MeshLambertMaterial({ color: colorHex });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            return mesh;
    }
}

// Create charge label sprite
function createChargeLabelSprite(charge, position, atomScale) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');

    // Format charge value
    const sign = charge >= 0 ? '+' : '';
    const text = sign + charge.toFixed(3);

    // Draw text with outline for visibility
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Outline
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.strokeText(text, 64, 32);

    // Fill with color based on charge
    ctx.fillStyle = charge >= 0 ? '#3b82f6' : '#ef4444';
    ctx.fillText(text, 64, 32);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false
    });
    const sprite = new THREE.Sprite(material);

    // Position above the atom
    const offset = atomScale * 0.8;
    sprite.position.set(position.x, position.y + offset, position.z);
    sprite.scale.set(1.2, 0.6, 1);

    return sprite;
}

// Create bond with custom colors (for charge coloring)
function createBondWithColor(pos1, pos2, bondRadius, color1Hex, color2Hex, styleName) {
    const group = new THREE.Group();

    const midpoint = new THREE.Vector3().addVectors(pos1, pos2).multiplyScalar(0.5);
    const direction = new THREE.Vector3().subVectors(pos2, pos1);
    const length = direction.length();
    const halfLength = length / 2;

    // Darken colors for bonds
    const darkenFactor = 0.7;
    const bondColor1 = new THREE.Color(color1Hex).multiplyScalar(darkenFactor).getHex();
    const bondColor2 = new THREE.Color(color2Hex).multiplyScalar(darkenFactor).getHex();

    let material1, material2;

    switch (styleName) {
        case 'neon':
            // Use lines for neon style
            const points1 = [pos1, midpoint];
            const geometry1 = new THREE.BufferGeometry().setFromPoints(points1);
            material1 = new THREE.LineBasicMaterial({ color: bondColor1, linewidth: 2 });
            group.add(new THREE.Line(geometry1, material1));

            const points2 = [midpoint, pos2];
            const geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
            material2 = new THREE.LineBasicMaterial({ color: bondColor2, linewidth: 2 });
            group.add(new THREE.Line(geometry2, material2));
            return group;

        case 'cartoon':
            material1 = new THREE.MeshToonMaterial({ color: bondColor1 });
            material2 = new THREE.MeshToonMaterial({ color: bondColor2 });
            break;

        case 'metallic':
            material1 = new THREE.MeshStandardMaterial({ color: bondColor1, metalness: 0.8, roughness: 0.2 });
            material2 = new THREE.MeshStandardMaterial({ color: bondColor2, metalness: 0.8, roughness: 0.2 });
            break;

        case 'glossy':
            material1 = new THREE.MeshPhongMaterial({ color: bondColor1, shininess: 100, specular: 0x444444 });
            material2 = new THREE.MeshPhongMaterial({ color: bondColor2, shininess: 100, specular: 0x444444 });
            break;

        case 'bubble':
            material1 = new THREE.MeshPhongMaterial({ color: bondColor1, transparent: true, opacity: 0.6, shininess: 100, specular: 0xffffff });
            material2 = new THREE.MeshPhongMaterial({ color: bondColor2, transparent: true, opacity: 0.6, shininess: 100, specular: 0xffffff });
            break;

        default:
            material1 = new THREE.MeshPhongMaterial({ color: bondColor1, shininess: 30 });
            material2 = new THREE.MeshPhongMaterial({ color: bondColor2, shininess: 30 });
    }

    // First half
    const cylGeom1 = new THREE.CylinderGeometry(bondRadius, bondRadius, halfLength, 16);
    const cylinder1 = new THREE.Mesh(cylGeom1, material1);
    const half1Mid = new THREE.Vector3().addVectors(pos1, midpoint).multiplyScalar(0.5);
    cylinder1.position.copy(half1Mid);
    cylinder1.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
    group.add(cylinder1);

    // Second half
    const cylGeom2 = new THREE.CylinderGeometry(bondRadius, bondRadius, halfLength, 16);
    const cylinder2 = new THREE.Mesh(cylGeom2, material2);
    const half2Mid = new THREE.Vector3().addVectors(midpoint, pos2).multiplyScalar(0.5);
    cylinder2.position.copy(half2Mid);
    cylinder2.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
    group.add(cylinder2);

    return group;
}

let scene = null;
let camera = null;
let renderer = null;
let controls = null;
let moleculeGroup = null;
let directionalLight = null;
let cameraNeedsFit = true;

// Axis helper scene
let axisScene = null;
let axisCamera = null;
let axisGroup = null;

// Animation state
let animationState = {
    isPlaying: false,
    currentFrame: 0,
    animationInterval: null
};

document.addEventListener('DOMContentLoaded', function() {
    initSettingsFromUI();
    setupEventListeners();
    initRenderer();
});

// Initialize settings from UI values on page load
function initSettingsFromUI() {
    const bondThresholdSlider = document.getElementById('bond-threshold');
    if (bondThresholdSlider) {
        settings.bondThreshold = parseFloat(bondThresholdSlider.value);
    }
    
    const bondThicknessSlider = document.getElementById('bond-thickness');
    if (bondThicknessSlider) {
        settings.bondThickness = parseFloat(bondThicknessSlider.value);
    }
    
    const atomSizeSlider = document.getElementById('atom-size');
    if (atomSizeSlider) {
        settings.atomSize = parseFloat(atomSizeSlider.value);
    }
    
    const animSpeedSlider = document.getElementById('animation-speed');
    if (animSpeedSlider) {
        settings.animationSpeed = parseInt(animSpeedSlider.value, 10);
    }
    
    const forceScaleSlider = document.getElementById('force-scale');
    if (forceScaleSlider) {
        settings.forceScale = parseFloat(forceScaleSlider.value);
    }
    
    const bgColorInput = document.getElementById('background-color');
    if (bgColorInput) {
        settings.backgroundColor = bgColorInput.value;
    }
    
    const cellColorInput = document.getElementById('cell-color');
    if (cellColorInput) {
        settings.cellColor = cellColorInput.value;
    }
    
    const styleSelect = document.getElementById('style');
    if (styleSelect) {
        settings.style = styleSelect.value;
    }
    
    const showCellCheckbox = document.getElementById('show-cell');
    if (showCellCheckbox) {
        settings.showCell = showCellCheckbox.checked;
    }
    
    const showBondCheckbox = document.getElementById('show-bond');
    if (showBondCheckbox) {
        settings.showBond = showBondCheckbox.checked;
    }
    
    const showShadingCheckbox = document.getElementById('show-shading');
    if (showShadingCheckbox) {
        settings.showShading = showShadingCheckbox.checked;
    }
    
    const showForcesCheckbox = document.getElementById('show-forces');
    if (showForcesCheckbox) {
        settings.showForces = showForcesCheckbox.checked;
    }
}

function initRenderer() {
    const viewer = document.getElementById('viewer');
    if (!viewer) return;

    const placeholderCanvas = document.getElementById('molecule-canvas');
    const helpText = document.getElementById('help-text');
    if (placeholderCanvas && placeholderCanvas.parentElement === viewer) {
        placeholderCanvas.remove();
    }

    renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        preserveDrawingBuffer: true  // Required for canvas capture (PNG/GIF export)
    });
    renderer.domElement.id = 'molecule-canvas';
    renderer.sortObjects = true;
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(Math.max(viewer.clientWidth, 1), Math.max(viewer.clientHeight, 1));
    
    // Enable better rendering for special effects like neon
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    if (helpText && helpText.parentElement === viewer) {
        viewer.insertBefore(renderer.domElement, helpText);
    } else {
        viewer.appendChild(renderer.domElement);
    }

    scene = new THREE.Scene();
    updateBackgroundColor();

    setupCamera();
    setupControls();

    // Lighting setup - matching old version
    directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    // Setup axis helper (XYZ indicator in corner)
    setupAxisHelper();

    window.addEventListener('resize', handleResize);
    handleResize();
    animate();
}

function setupCamera() {
    const viewer = document.getElementById('viewer');
    if (!viewer) return;

    const width = Math.max(viewer.clientWidth, 1);
    const height = Math.max(viewer.clientHeight, 1);
    const aspect = width / height;

    let newCamera;
    if (settings.viewMode === 'Orthographic') {
        const frustumSize = 20;
        newCamera = new THREE.OrthographicCamera(
            (frustumSize * aspect) / -2,
            (frustumSize * aspect) / 2,
            frustumSize / 2,
            frustumSize / -2,
            -1000,
            1000
        );
    } else {
        newCamera = new THREE.PerspectiveCamera(55, aspect, 0.1, 2000);
    }

    if (camera) {
        newCamera.position.copy(camera.position);
        newCamera.zoom = camera.zoom;
        newCamera.updateProjectionMatrix();
    } else {
        newCamera.position.set(0, 0, 10);
    }

    camera = newCamera;
}

function setupControls() {
    if (!renderer || !camera) return;

    const target = controls ? controls.target.clone() : new THREE.Vector3();
    if (controls) {
        controls.dispose();
    }

    if (settings.rotationMode === 'Orbit') {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
    } else {
        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
    }

    controls.target.copy(target);
    controls.update();
}

function handleResize() {
    if (!renderer || !camera) return;
    const viewer = document.getElementById('viewer');
    if (!viewer) return;
    const width = Math.max(viewer.clientWidth, 1);
    const height = Math.max(viewer.clientHeight, 1);
    renderer.setSize(width, height);

    if (camera.isPerspectiveCamera) {
        camera.aspect = width / height;
    } else {
        const frustumSize = 20;
        const aspect = width / height;
        camera.left = (frustumSize * aspect) / -2;
        camera.right = (frustumSize * aspect) / 2;
        camera.top = frustumSize / 2;
        camera.bottom = frustumSize / -2;
    }

    camera.updateProjectionMatrix();
    if (controls && typeof controls.handleResize === 'function') {
        controls.handleResize();
    }
}

function setupAxisHelper() {
    // Create a separate scene for the axis helper
    axisScene = new THREE.Scene();
    axisScene.background = null;  // Transparent background

    // Create orthographic camera for axis helper (centered on origin)
    const axisViewSize = 100;  // How much world units to show
    axisCamera = new THREE.OrthographicCamera(-axisViewSize, axisViewSize, axisViewSize, -axisViewSize, -200, 200);
    axisCamera.position.set(0, 0, 100);

    // Create a group to hold all axis objects (will be rotated)
    axisGroup = new THREE.Group();

    // Axis colors
    const colors = {
        x: 0xff4444,  // Red
        y: 0x44cc44,  // Green
        z: 0x4488ff   // Blue
    };

    const axisLength = 50;
    const arrowHeadLength = 12;
    const arrowHeadWidth = 6;

    // Create arrows for each axis starting from origin
    const xDir = new THREE.Vector3(1, 0, 0);
    const yDir = new THREE.Vector3(0, 1, 0);
    const zDir = new THREE.Vector3(0, 0, 1);
    const origin = new THREE.Vector3(0, 0, 0);

    const xArrow = new THREE.ArrowHelper(xDir, origin, axisLength, colors.x, arrowHeadLength, arrowHeadWidth);
    const yArrow = new THREE.ArrowHelper(yDir, origin, axisLength, colors.y, arrowHeadLength, arrowHeadWidth);
    const zArrow = new THREE.ArrowHelper(zDir, origin, axisLength, colors.z, arrowHeadLength, arrowHeadWidth);

    // Make arrows thicker
    xArrow.line.material.linewidth = 2;
    yArrow.line.material.linewidth = 2;
    zArrow.line.material.linewidth = 2;

    axisGroup.add(xArrow);
    axisGroup.add(yArrow);
    axisGroup.add(zArrow);

    // Create text labels using sprites
    const createTextSprite = (text, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Convert hex color to CSS
        const cssColor = '#' + color.toString(16).padStart(6, '0');
        ctx.fillStyle = cssColor;
        ctx.fillText(text, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(14, 14, 1);
        return sprite;
    };

    const xLabel = createTextSprite('X', colors.x);
    const yLabel = createTextSprite('Y', colors.y);
    const zLabel = createTextSprite('Z', colors.z);

    xLabel.position.set(axisLength + 10, 0, 0);
    yLabel.position.set(0, axisLength + 10, 0);
    zLabel.position.set(0, 0, axisLength + 10);

    axisGroup.add(xLabel);
    axisGroup.add(yLabel);
    axisGroup.add(zLabel);

    axisScene.add(axisGroup);

    // Add ambient light to axis scene
    const axisAmbient = new THREE.AmbientLight(0xffffff, 1.0);
    axisScene.add(axisAmbient);
}

function animate() {
    requestAnimationFrame(animate);
    if (controls && typeof controls.update === 'function') {
        controls.update();
    }
    // Light behavior depends on shading setting
    if (directionalLight && camera) {
        if (settings.showShading) {
            // Light position relative to camera for consistent shading direction
            // Light stays in camera space, so shading direction is fixed from viewer's perspective
            const offset = new THREE.Vector3(5, 8, 5);
            const lightPos = camera.position.clone().add(
                offset.applyQuaternion(camera.quaternion)
            );
            directionalLight.position.copy(lightPos);
        } else {
            // Light follows camera for flat lighting (no shading)
            directionalLight.position.copy(camera.position);
        }
    }
    if (renderer && scene && camera) {
        renderer.render(scene, camera);

        // Render axis helper in bottom-left corner (transparent overlay)
        if (settings.showAxis && axisScene && axisCamera && axisGroup) {
            // Rotate axis group inversely to camera - shows world axes from camera's view
            axisGroup.quaternion.copy(camera.quaternion).invert();

            // Save current state
            const currentViewport = renderer.getViewport(new THREE.Vector4());
            const currentAutoClear = renderer.autoClear;

            // Set viewport for axis helper (bottom-left corner)
            const axisViewportSize = 150;
            const axisMarginX = 15;
            const axisMarginY = 20;
            renderer.setViewport(axisMarginX, axisMarginY, axisViewportSize, axisViewportSize);
            renderer.setScissor(axisMarginX, axisMarginY, axisViewportSize, axisViewportSize);
            renderer.setScissorTest(true);

            // Disable auto clear to preserve main scene, only clear depth
            renderer.autoClear = false;
            renderer.clearDepth();

            // Render axis scene (transparent background)
            renderer.render(axisScene, axisCamera);

            // Restore state
            renderer.autoClear = currentAutoClear;
            renderer.setScissorTest(false);
            renderer.setViewport(currentViewport);
        }
    }
}

function disposeObject3D(object) {
    object.traverse(child => {
        if (child.geometry) {
            child.geometry.dispose();
        }
        if (child.material) {
            if (Array.isArray(child.material)) {
                child.material.forEach(mat => mat.dispose && mat.dispose());
            } else if (child.material.dispose) {
                child.material.dispose();
            }
        }
        if (child.texture && child.texture.dispose) {
            child.texture.dispose();
        }
    });
}


function renderMolecule() {
    if (!scene || !camera || !renderer) return;
    if (!molecularData || molecularData.length === 0) return;

    if (moleculeGroup) {
        scene.remove(moleculeGroup);
        disposeObject3D(moleculeGroup);
    }

    moleculeGroup = new THREE.Group();
    
    // Use current frame for animation
    const frameIndex = animationState.currentFrame % molecularData.length;
    const molecule = molecularData[frameIndex];
    let positions = molecule.positions.map(pos => new THREE.Vector3(...pos));
    let symbols = molecule.symbols;
    
    // Apply periodic boundary conditions if requested
    if (periodicities.length > 0 && molecule.cell) {
        const extended = applyPeriodicBoundaries(positions, symbols, molecule.cell, periodicities);
        positions = extended.positions;
        symbols = extended.symbols;
        console.log('Applied periodicities:', periodicities);
        console.log('Extended atoms:', positions.length, 'from', molecule.positions.length);
    }

    const styleName = (settings.style || 'cartoon').toLowerCase();
    console.log('Rendering with style:', styleName);
    console.log('Available atom factories:', Object.keys(atomFactories));
    console.log('Available bond factories:', Object.keys(bondFactories));
    
    const atomFactory = atomFactories[styleName] || atomFactories['default'];
    const bondFactory = bondFactories[styleName] || bondFactories['default'];
    
    if (!atomFactory || !bondFactory) {
        console.error('Factory not found for style:', styleName);
        return;
    }

    const atomScale = Math.max(settings.atomSize, 0.05);
    const bondRadius = Math.max(settings.bondThickness, 0.005);
    const bondCutoff = settings.bondThreshold;

    const uniqueSymbols = [...new Set(symbols)];
    const greyColorMap = {};
    if (uniqueSymbols.length > 0) {
        uniqueSymbols.forEach((sym, idx) => {
            const lightness = (idx + 1) / (uniqueSymbols.length + 1);
            greyColorMap[sym] = new THREE.Color().setHSL(0, 0, lightness).getHex();
        });
    }
    const helpers = { greyColorMap };

    if (settings.showCell && molecule.cell) {
        const cellVectors = molecule.cell.map(c => new THREE.Vector3(...c));
        const points = [
            new THREE.Vector3(0, 0, 0), cellVectors[0],
            new THREE.Vector3(0, 0, 0), cellVectors[1],
            new THREE.Vector3(0, 0, 0), cellVectors[2],
            cellVectors[0], cellVectors[0].clone().add(cellVectors[1]),
            cellVectors[0], cellVectors[0].clone().add(cellVectors[2]),
            cellVectors[1], cellVectors[1].clone().add(cellVectors[0]),
            cellVectors[1], cellVectors[1].clone().add(cellVectors[2]),
            cellVectors[2], cellVectors[2].clone().add(cellVectors[0]),
            cellVectors[2], cellVectors[2].clone().add(cellVectors[1]),
            cellVectors[0].clone().add(cellVectors[1]), cellVectors[0].clone().add(cellVectors[1]).add(cellVectors[2]),
            cellVectors[0].clone().add(cellVectors[2]), cellVectors[0].clone().add(cellVectors[1]).add(cellVectors[2]),
            cellVectors[1].clone().add(cellVectors[2]), cellVectors[0].clone().add(cellVectors[1]).add(cellVectors[2])
        ];
        const cellGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const cellColor = new THREE.Color(settings.cellColor);
        const cellMaterial = new THREE.LineBasicMaterial({ color: cellColor });
        const cellMesh = new THREE.LineSegments(cellGeometry, cellMaterial);
        cellMesh.renderOrder = 2;
        moleculeGroup.add(cellMesh);
    }

    // Get charges for current frame (if available)
    const frameCharges = molecule.charges || [];
    const useChargeColor = settings.colorBy === 'Charge' && chargeStats.hasCharges && frameCharges.length === positions.length;

    // Pre-calculate charge colors for all atoms
    const atomChargeColors = [];
    if (useChargeColor) {
        for (let i = 0; i < positions.length; i++) {
            const charge = frameCharges[i] || 0;
            atomChargeColors[i] = getChargeColor(charge, settings.normalizeCharges);
        }
    }

    if (settings.showBond) {
        let bondCount = 0;
        for (let i = 0; i < positions.length; i++) {
            for (let j = i + 1; j < positions.length; j++) {
                const dist = positions[i].distanceTo(positions[j]);

                // Calculate bond cutoff based on covalent radii of both atoms
                const info1 = atomInfo[symbols[i]] || atomInfo['default'];
                const info2 = atomInfo[symbols[j]] || atomInfo['default'];
                const covalentRadiusSum = info1.radius + info2.radius;
                const adjustedCutoff = covalentRadiusSum * bondCutoff;

                if (dist <= adjustedCutoff) {
                    let bond;
                    // Styles with fixed bond colors (not dependent on atom colors)
                    const fixedBondStyles = ['rowan', 'neon', 'cartoon', '2d'];
                    if (useChargeColor && !fixedBondStyles.includes(styleName)) {
                        // Use charge-based coloring for bonds
                        bond = createBondWithColor(
                            positions[i],
                            positions[j],
                            bondRadius,
                            atomChargeColors[i],
                            atomChargeColors[j],
                            styleName
                        );
                    } else {
                        // Use element-based coloring or fixed style coloring
                        bond = bondFactory(
                            positions[i],
                            positions[j],
                            symbols[i],
                            symbols[j],
                            bondRadius,
                            atomScale,
                            helpers
                        );
                    }
                    if (bond) {
                        bond.renderOrder = 1;
                        moleculeGroup.add(bond);
                        bondCount++;
                    }
                }
            }
        }
        console.log('Total bonds created:', bondCount, 'for style:', styleName);
    }

    for (let i = 0; i < positions.length; i++) {
        let atom;

        if (useChargeColor) {
            // Use charge-based coloring (colors already calculated)
            atom = createAtomWithColor(positions[i], symbols[i], atomScale, atomChargeColors[i], styleName);
        } else {
            // Use element-based coloring (default)
            atom = atomFactory(positions[i], symbols[i], atomScale, helpers);
            if (!atom) {
                atom = atomFactories['default'](positions[i], symbols[i], atomScale, helpers);
            }
        }

        if (atom) {
            atom.renderOrder = 0;
            moleculeGroup.add(atom);
        }
    }

    // Add charge labels if enabled
    if (settings.showChargeLabels && useChargeColor && frameCharges.length > 0) {
        for (let i = 0; i < positions.length; i++) {
            const charge = frameCharges[i] || 0;
            const label = createChargeLabelSprite(charge, positions[i], atomScale);
            if (label) {
                label.renderOrder = 4;
                moleculeGroup.add(label);
            }
        }
    }

    if (settings.showForces && molecule.forces) {
        const arrowColor = 0xff0000;
        const forceScale = settings.forceScale || 0.5;
        const headLength = 0.2;
        const headWidth = 0.1;
        for (let i = 0; i < positions.length; i++) {
            const forceVec = new THREE.Vector3(...molecule.forces[i]);
            if (forceVec.lengthSq() === 0) continue;
            const direction = forceVec.clone().normalize();
            const length = forceVec.length() * forceScale;
            const arrowHelper = new THREE.ArrowHelper(direction, positions[i], length, arrowColor, headLength, headWidth);
            arrowHelper.renderOrder = 3;
            moleculeGroup.add(arrowHelper);
        }
    }

    scene.add(moleculeGroup);

    if (cameraNeedsFit) {
        fitCameraToMolecule(moleculeGroup);
    }
}


function fitCameraToMolecule(group) {
    if (!camera || !controls) return;
    const box = new THREE.Box3().setFromObject(group);
    if (!isFinite(box.max.x) || !isFinite(box.max.y) || !isFinite(box.max.z)) return;
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z, 1);

    if (camera.isPerspectiveCamera) {
        const halfFov = THREE.MathUtils.degToRad(camera.fov / 2);
        const distance = maxDim / (2 * Math.tan(halfFov)) + maxDim;
        camera.position.copy(center.clone().add(new THREE.Vector3(distance, distance, distance)));
    } else {
        const viewer = document.getElementById('viewer');
        const aspect = viewer ? Math.max(viewer.clientWidth, 1) / Math.max(viewer.clientHeight, 1) : 1;
        camera.left = (-maxDim * aspect);
        camera.right = (maxDim * aspect);
        camera.top = maxDim;
        camera.bottom = -maxDim;
    }

    controls.target.copy(center);
    controls.update();
    camera.lookAt(center);
    camera.updateProjectionMatrix();
    cameraNeedsFit = false;
}

function updateBackgroundColor() {
    if (!scene || !renderer) return;
    const color = new THREE.Color(settings.backgroundColor || '#111827');
    scene.background = color;
    renderer.setClearColor(color, 1);
}

function updateShading() {
    // This function controls shading (lighting), not cast shadows
    // When enabled: light offset from camera creates visible shading on spheres
    // When disabled: light follows camera for flat appearance
    renderMolecule();
}

function updateFrameDisplay() {
    const frameSlider = document.getElementById('frame-slider');
    const frameValue = document.getElementById('frame-value');
    
    if (frameSlider && molecularData) {
        const totalFrames = molecularData.length;
        frameSlider.max = totalFrames;
        frameSlider.value = animationState.currentFrame + 1;  // 1-indexed for display
        
        if (frameValue) {
            frameValue.textContent = `${animationState.currentFrame + 1} / ${totalFrames}`;
        }
    }
}

function toggleAnimation() {
    if (!molecularData || molecularData.length <= 1) {
        console.log('No animation frames available');
        return;
    }
    
    const playBtn = document.getElementById('play-btn');
    
    if (animationState.isPlaying) {
        // Pause
        animationState.isPlaying = false;
        if (animationState.animationInterval) {
            clearInterval(animationState.animationInterval);
            animationState.animationInterval = null;
        }
        
        // Update button icon to play
        if (playBtn) {
            playBtn.innerHTML = `
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            `;
        }
    } else {
        // Play
        animationState.isPlaying = true;
        const fps = settings.animationSpeed || 30;
        const interval = 1000 / fps;

        animationState.animationInterval = setInterval(() => {
            animationState.currentFrame = (animationState.currentFrame + 1) % molecularData.length;
            updateFrameDisplay();
            renderMolecule();
            // Update energy plot marker
            if (settings.showEnergyPlot && energyPlotData.hasEnergy) {
                drawEnergyPlot();
            }
        }, interval);
        
        // Update button icon to pause
        if (playBtn) {
            playBtn.innerHTML = `
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            `;
        }
    }
}

function getCurrentFrameAsXYZ() {
    if (!molecularData || molecularData.length === 0) {
        return '';
    }
    
    const frameIndex = animationState.currentFrame % molecularData.length;
    const molecule = molecularData[frameIndex];
    
    if (!molecule || !molecule.positions || !molecule.symbols) {
        return '';
    }
    
    const numAtoms = molecule.symbols.length;
    let xyzString = `${numAtoms}\n`;
    
    // Comment line (can include energy, frame number, etc.)
    xyzString += `Frame ${frameIndex + 1}`;
    if (molecule.energy !== undefined) {
        xyzString += ` Energy: ${molecule.energy}`;
    }
    xyzString += '\n';
    
    // Atom lines: symbol x y z
    for (let i = 0; i < numAtoms; i++) {
        const symbol = molecule.symbols[i];
        const pos = molecule.positions[i];
        xyzString += `${symbol}  ${pos[0].toFixed(6)}  ${pos[1].toFixed(6)}  ${pos[2].toFixed(6)}\n`;
    }
    
    return xyzString;
}

function copyCurrentFrameToClipboard() {
    const xyzString = getCurrentFrameAsXYZ();
    
    if (!xyzString) {
        alert('No molecular data to copy');
        return;
    }
    
    // Try to copy to clipboard
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(xyzString).then(() => {
            // Show success feedback
            const copyBtn = document.getElementById('copy-btn');
            if (copyBtn) {
                const originalHTML = copyBtn.innerHTML;
                copyBtn.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                `;
                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                }, 1000);
            }
            console.log('Copied XYZ to clipboard');
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    } else {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = xyzString;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            alert('Copied to clipboard!');
        } catch (err) {
            alert('Failed to copy to clipboard');
        }
        document.body.removeChild(textArea);
    }
}

function getAllFramesAsXYZ() {
    if (!molecularData || molecularData.length === 0) return '';

    let xyzString = '';
    for (let i = 0; i < molecularData.length; i++) {
        const molecule = molecularData[i];
        if (!molecule) continue;

        const numAtoms = molecule.positions.length;
        xyzString += `${numAtoms}\n`;
        xyzString += `Frame ${i + 1}`;
        if (molecule.energy !== undefined) {
            xyzString += ` Energy: ${molecule.energy}`;
        }
        xyzString += '\n';

        for (let j = 0; j < numAtoms; j++) {
            const symbol = molecule.symbols[j];
            const pos = molecule.positions[j];
            xyzString += `${symbol}  ${pos[0].toFixed(6)}  ${pos[1].toFixed(6)}  ${pos[2].toFixed(6)}\n`;
        }
    }

    return xyzString;
}

function copyAllFramesToClipboard() {
    const xyzString = getAllFramesAsXYZ();

    if (!xyzString) {
        alert('No molecular data to copy');
        return;
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(xyzString).then(() => {
            const copyAllBtn = document.getElementById('copy-all-btn');
            if (copyAllBtn) {
                const originalHTML = copyAllBtn.innerHTML;
                copyAllBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                `;
                setTimeout(() => {
                    copyAllBtn.innerHTML = originalHTML;
                }, 1000);
            }
            console.log(`Copied ${molecularData.length} frames to clipboard`);
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    } else {
        const textArea = document.createElement('textarea');
        textArea.value = xyzString;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            alert(`Copied ${molecularData.length} frames to clipboard!`);
        } catch (err) {
            alert('Failed to copy to clipboard');
        }
        document.body.removeChild(textArea);
    }
}

function setMolecularData(data) {
    molecularData = Array.isArray(data) ? data : [data];
    cameraNeedsFit = true;
    
    // Reset animation state
    animationState.currentFrame = 0;
    animationState.isPlaying = false;
    if (animationState.animationInterval) {
        clearInterval(animationState.animationInterval);
        animationState.animationInterval = null;
    }
    
    // Update frame display
    updateFrameDisplay();
    
    // Show/hide animation controls based on number of frames
    const animationCard = document.querySelector('.card:has(#play-btn)');
    if (animationCard) {
        animationCard.style.display = molecularData.length > 1 ? 'block' : 'none';
    }
    
    // Show/hide cell color control based on whether any molecule has a cell
    const hasCell = molecularData.some(mol => mol && mol.cell);
    const cellColorGroup = document.getElementById('cell-color-group');
    if (cellColorGroup) {
        cellColorGroup.style.display = hasCell ? 'block' : 'none';
    }

    // Extract energy data for plotting
    extractEnergyData();

    // Check for charge data and update UI
    checkChargesInData();
    updateChargeUI();

    // Show/hide energy plot checkbox based on energy availability
    if (!energyPlotData.hasEnergy) {
        const energyCheckbox = document.getElementById('show-energy-plot');
        if (energyCheckbox) {
            energyCheckbox.checked = false;
            energyCheckbox.parentElement.parentElement.parentElement.style.opacity = '0.5';
        }
    } else {
        const energyCheckbox = document.getElementById('show-energy-plot');
        if (energyCheckbox) {
            energyCheckbox.parentElement.parentElement.parentElement.style.opacity = '1';
        }
    }

    renderMolecule();

    // Draw energy plot if enabled
    if (settings.showEnergyPlot && energyPlotData.hasEnergy) {
        drawEnergyPlot();
    }
}

function setDownloadName(name) {
    downloadBaseName = name;
    downloadCounters = { png: 0, gif: 0 };  // Reset counters
    console.log('Download base name set to:', name);
}

function addPeriodicity() {
    const select = document.getElementById('periodicity-select');
    const value = select.value;
    if (!periodicities.includes(value)) {
        periodicities.push(value);
        renderPeriodicities();
        renderMolecule();  // Re-render with new periodicity
    }
}

function removePeriodicity(value) {
    periodicities = periodicities.filter(p => p !== value);
    renderPeriodicities();
    renderMolecule();  // Re-render without periodicity
}

function renderPeriodicities() {
    const container = document.getElementById('periodicities-list');
    container.innerHTML = '';
    periodicities.forEach(periodicity => {
        const item = document.createElement('div');
        item.className = 'periodicity-item';
        item.innerHTML = `
            <span class="periodicity-value">${periodicity}</span>
            <button class="btn" onclick="removePeriodicity('${periodicity}')" style="padding: 0.25rem; min-width: 30px;">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        `;
        container.appendChild(item);
    });
}

/**
 * Apply periodic boundary conditions to create replicated atoms
 * @param {Array} positions - Original atom positions
 * @param {Array} symbols - Original atom symbols
 * @param {Array} cell - Unit cell vectors
 * @param {Array} periodicities - List of periodicity directions (e.g., ['+x', '±y'])
 * @returns {Object} Extended positions and symbols
 */
function applyPeriodicBoundaries(positions, symbols, cell, periodicities) {
    if (!cell || periodicities.length === 0) {
        return { positions, symbols };
    }
    
    const cellVectors = cell.map(c => new THREE.Vector3(...c));
    const extendedPositions = [...positions];
    const extendedSymbols = [...symbols];
    
    periodicities.forEach(periodicity => {
        const currentCount = extendedPositions.length;
        
        // Parse periodicity string (e.g., '+x', '±y', '-z')
        const direction = periodicity.slice(-1).toLowerCase();  // 'x', 'y', or 'z'
        const sign = periodicity.slice(0, -1);  // '+', '-', or '±'
        
        const axisIndex = { 'x': 0, 'y': 1, 'z': 2 }[direction];
        const cellVector = cellVectors[axisIndex];
        
        // Determine which directions to replicate
        const directions = [];
        if (sign === '+' || sign === '±') directions.push(1);
        if (sign === '-' || sign === '±') directions.push(-1);
        
        // Replicate atoms in specified directions
        directions.forEach(dir => {
            for (let i = 0; i < currentCount; i++) {
                const newPos = extendedPositions[i].clone().add(cellVector.clone().multiplyScalar(dir));
                extendedPositions.push(newPos);
                extendedSymbols.push(extendedSymbols[i]);
            }
        });
    });
    
    return { positions: extendedPositions, symbols: extendedSymbols };
}

function setupEventListeners() {
    // Helper function to safely add event listener
    function safeAddListener(id, event, handler) {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener(event, handler);
        }
    }

    safeAddListener('sidebar-toggle', 'click', toggleSidebar);

    safeAddListener('bond-threshold', 'input', function() {
        const valueEl = document.getElementById('bond-threshold-value');
        if (valueEl) valueEl.textContent = this.value;
        settings.bondThreshold = parseFloat(this.value);
        renderMolecule();
    });

    safeAddListener('bond-thickness', 'input', function() {
        const valueEl = document.getElementById('bond-thickness-value');
        if (valueEl) valueEl.textContent = parseFloat(this.value).toFixed(2);
        settings.bondThickness = parseFloat(this.value);
        renderMolecule();
    });

    safeAddListener('atom-size', 'input', function() {
        const valueEl = document.getElementById('atom-size-value');
        if (valueEl) valueEl.textContent = parseFloat(this.value).toFixed(1) + '×';
        settings.atomSize = parseFloat(this.value);
        renderMolecule();
    });

    safeAddListener('animation-speed', 'input', function() {
        const valueEl = document.getElementById('animation-speed-value');
        if (valueEl) valueEl.textContent = this.value;
        settings.animationSpeed = parseInt(this.value, 10);
        
        // If animation is playing, restart with new speed
        if (animationState.isPlaying) {
            toggleAnimation();  // Pause
            toggleAnimation();  // Play with new speed
        }
    });

    safeAddListener('force-scale', 'input', function() {
        const valueEl = document.getElementById('force-scale-value');
        if (valueEl) valueEl.textContent = parseFloat(this.value).toFixed(1) + '×';
        settings.forceScale = parseFloat(this.value);
        if (settings.showForces) {
            renderMolecule();
        }
    });

    safeAddListener('frame-slider', 'input', function() {
        const frameNum = parseInt(this.value, 10);
        animationState.currentFrame = frameNum - 1;  // 0-indexed
        updateFrameDisplay();
        renderMolecule();
        // Update energy plot
        if (settings.showEnergyPlot && energyPlotData.hasEnergy) {
            drawEnergyPlot();
        }
    });

    safeAddListener('background-color', 'input', function() {
        const valueEl = document.getElementById('background-color-value');
        if (valueEl) valueEl.textContent = this.value;
        const viewerContainer = document.querySelector('.viewer-container');
        if (viewerContainer) {
            viewerContainer.style.background = `linear-gradient(135deg, ${this.value}, ${darkenColorHex(this.value, 20)})`;
        }
        settings.backgroundColor = this.value;
        updateBackgroundColor();
    });

    safeAddListener('cell-color', 'input', function() {
        const valueEl = document.getElementById('cell-color-value');
        if (valueEl) valueEl.textContent = this.value;
        settings.cellColor = this.value;
        renderMolecule();
    });

    safeAddListener('style', 'change', function() {
        settings.style = this.value;
        renderMolecule();
    });

    safeAddListener('show-cell', 'change', function() {
        settings.showCell = this.checked;
        renderMolecule();
    });

    safeAddListener('show-bond', 'change', function() {
        settings.showBond = this.checked;
        renderMolecule();
    });

    safeAddListener('show-shading', 'change', function() {
        settings.showShading = this.checked;
        updateShading();
    });

    safeAddListener('show-energy-plot', 'change', function() {
        settings.showEnergyPlot = this.checked;
        const plotContainer = document.getElementById('energy-plot-container');
        if (plotContainer) {
            plotContainer.style.display = this.checked ? 'block' : 'none';
            if (this.checked) {
                drawEnergyPlot();
            }
        }
    });

    safeAddListener('show-forces', 'change', function() {
        settings.showForces = this.checked;
        renderMolecule();
    });

    safeAddListener('show-axis', 'change', function() {
        settings.showAxis = this.checked;
        render();
    });

    // Color by selection (Element or Charge)
    safeAddListener('color-by-select', 'change', function() {
        settings.colorBy = this.value;
        updateChargeUI();
        renderMolecule();
    });

    // Normalize charges toggle
    safeAddListener('normalize-charges', 'change', function() {
        settings.normalizeCharges = this.checked;
        updateColorbarLabels();
        renderMolecule();
    });

    // Show charge labels toggle
    safeAddListener('show-charge-labels', 'change', function() {
        settings.showChargeLabels = this.checked;
        renderMolecule();
    });

    if (document.getElementById('orthographic-btn') && document.getElementById('perspective-btn')) {
        setupButtonGroup('view-mode', ['orthographic-btn', 'perspective-btn']);
    }
    if (document.getElementById('trackball-btn') && document.getElementById('orbit-btn')) {
        setupButtonGroup('rotation-mode', ['trackball-btn', 'orbit-btn']);
    }

    safeAddListener('add-periodicity-btn', 'click', addPeriodicity);
    safeAddListener('play-btn', 'click', toggleAnimation);
    safeAddListener('copy-btn', 'click', copyCurrentFrameToClipboard);
    safeAddListener('copy-all-btn', 'click', copyAllFramesToClipboard);
    safeAddListener('video-btn', 'click', saveAsGIF);
    safeAddListener('download-btn', 'click', saveAsPNG);

    // Energy plot resize handle
    setupEnergyPlotResize();
}

function setupEnergyPlotResize() {
    const handle = document.getElementById('energy-plot-resize-handle');
    const container = document.getElementById('energy-plot-container');
    if (!handle || !container) return;

    let isResizing = false;
    let startY = 0;
    let startHeight = 0;

    handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = container.offsetHeight;
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = startY - e.clientY;
        const newHeight = Math.min(400, Math.max(80, startHeight + deltaY));
        container.style.height = newHeight + 'px';
        drawEnergyPlot();
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
        }
    });
}

function saveAsPNG() {
    if (!renderer || !scene || !camera) {
        alert('Renderer not ready');
        return;
    }
    
    // Store original background
    const originalBackground = scene.background;
    
    // Set transparent background
    scene.background = null;
    renderer.setClearColor(0x000000, 0); // Transparent
    
    // Render one frame
    renderer.render(scene, camera);
    
    // Get canvas data as PNG
    renderer.domElement.toBlob(function(blob) {
        // Restore original background
        scene.background = originalBackground;
        updateBackgroundColor();
        
        // Generate filename with counter to avoid overwriting
        let filename;
        if (downloadCounters.png === 0) {
            filename = `${downloadBaseName}.png`;
        } else {
            filename = `${downloadBaseName}_${downloadCounters.png}.png`;
        }
        downloadCounters.png++;
        
        // Try multiple download methods for better compatibility
        const url = URL.createObjectURL(blob);
        
        // Method 1: Try standard download attribute
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        
        try {
            link.click();
            console.log('PNG download initiated:', filename);
        } catch (e) {
            console.log('Standard download failed, trying alternative:', e);
            // Method 2: Try opening in new window (for Jupyter)
            try {
                const win = window.open(url, '_blank');
                if (!win) {
                    // Method 3: Try data URL
                    const reader = new FileReader();
                    reader.onload = function() {
                        const dataUrl = reader.result;
                        const newLink = document.createElement('a');
                        newLink.href = dataUrl;
                        newLink.download = filename;
                        document.body.appendChild(newLink);
                        newLink.click();
                        document.body.removeChild(newLink);
                    };
                    reader.readAsDataURL(blob);
                }
            } catch (e2) {
                console.error('All download methods failed:', e2);
                alert('Download failed. Please try saving the HTML file and opening it directly in a browser.');
            }
        }
        
        // Cleanup
        setTimeout(() => {
            if (link.parentNode) {
                document.body.removeChild(link);
            }
            URL.revokeObjectURL(url);
        }, 1000);
    }, 'image/png');
}

function saveAsGIF() {
    if (!molecularData || molecularData.length <= 1) {
        alert('No animation frames available for GIF');
        return;
    }
    
    if (!renderer || !scene || !camera) {
        alert('Renderer not ready');
        return;
    }
    
    // Check if gifshot is loaded
    if (typeof gifshot === 'undefined') {
        alert('GIF library not loaded');
        console.error('gifshot is undefined');
        return;
    }
    
    const videoBtn = document.getElementById('video-btn');
    const originalHTML = videoBtn ? videoBtn.innerHTML : '';
    
    try {
        const fps = settings.animationSpeed || 30;
        const interval = 1 / fps;
        
        console.log('Creating GIF at', fps, 'fps');
        console.log('Total frames:', molecularData.length);
        
        // Show progress message
        if (videoBtn) {
            videoBtn.innerHTML = '<span style="font-size: 10px;">Processing...</span>';
            videoBtn.disabled = true;
        }
        
        // Store current frame
        const originalFrame = animationState.currentFrame;
        
        // Capture all frames as data URLs
        const images = [];
        for (let i = 0; i < molecularData.length; i++) {
            animationState.currentFrame = i;
            renderMolecule();
            renderer.render(scene, camera);
            
            // Get frame as data URL
            const dataURL = renderer.domElement.toDataURL('image/png');
            images.push(dataURL);
            
            console.log('Captured frame', i + 1, 'of', molecularData.length);
        }
        
        // Restore original frame
        animationState.currentFrame = originalFrame;
        renderMolecule();
        
        console.log('Creating GIF from', images.length, 'frames...');
        
        // Create GIF using gifshot
        gifshot.createGIF({
            images: images,
            gifWidth: renderer.domElement.clientWidth,
            gifHeight: renderer.domElement.clientHeight,
            interval: interval,
            numFrames: images.length,
            frameDuration: 1,
            sampleInterval: 10,
            numWorkers: 2
        }, function(obj) {
            if (!obj.error) {
                console.log('GIF created successfully');
                
                // Generate filename with counter to avoid overwriting
                let filename;
                if (downloadCounters.gif === 0) {
                    filename = `${downloadBaseName}.gif`;
                } else {
                    filename = `${downloadBaseName}_${downloadCounters.gif}.gif`;
                }
                downloadCounters.gif++;
                
                // Try multiple download methods for better compatibility
                const link = document.createElement('a');
                link.href = obj.image;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                
                try {
                    link.click();
                } catch (e) {
                    // Try opening in new window (for Jupyter)
                    try {
                        const win = window.open(obj.image, '_blank');
                        if (!win) {
                            alert('Download blocked. Please allow popups or save the HTML file and open it directly in a browser.');
                        }
                    } catch (e2) {
                        console.error('All download methods failed:', e2);
                        alert('Download failed. Please try saving the HTML file and opening it directly in a browser.');
                    }
                }
                
                // Cleanup
                setTimeout(() => {
                    if (link.parentNode) {
                        document.body.removeChild(link);
                    }
                }, 1000);
                
                // Restore button
                if (videoBtn) {
                    videoBtn.innerHTML = originalHTML;
                    videoBtn.disabled = false;
                }
            } else {
                console.error('GIF creation error:', obj.error);
                alert('Failed to create GIF: ' + obj.error);
                if (videoBtn) {
                    videoBtn.innerHTML = originalHTML;
                    videoBtn.disabled = false;
                }
            }
        });
        
    } catch (error) {
        console.error('GIF creation error:', error);
        alert('Failed to create GIF: ' + error.message);
        if (videoBtn) {
            videoBtn.innerHTML = originalHTML;
            videoBtn.disabled = false;
        }
    }
}

function setupButtonGroup(groupName, buttonIds) {
    buttonIds.forEach(id => {
        const button = document.getElementById(id);
        button.addEventListener('click', function() {
            buttonIds.forEach(btnId => {
                document.getElementById(btnId).classList.remove('active');
            });
            this.classList.add('active');

            if (groupName === 'rotation-mode') {
                settings.rotationMode = (id === 'trackball-btn') ? 'TrackBall' : 'Orbit';
                setupControls();
            } else if (groupName === 'view-mode') {
                settings.viewMode = (id === 'orthographic-btn') ? 'Orthographic' : 'Perspective';
                setupCamera();
                setupControls();
                cameraNeedsFit = true;
                renderMolecule();
            }
        });
    });
}

function toggleSidebar() {
    sidebarOpen = !sidebarOpen;
    const sidebar = document.getElementById('sidebar');
    if (sidebarOpen) {
        sidebar.style.width = '320px';
        sidebar.classList.remove('collapsed');
    } else {
        sidebar.style.width = '0';
        sidebar.classList.add('collapsed');
    }

    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 350);
}

function toggleCard(cardId) {
    cards[cardId] = !cards[cardId];
    const content = document.getElementById(cardId + '-content');
    const arrow = document.getElementById(cardId + '-arrow');

    if (cards[cardId]) {
        content.classList.remove('collapsed');
        arrow.style.transform = 'rotate(0deg)';
    } else {
        content.classList.add('collapsed');
        arrow.style.transform = 'rotate(-90deg)';
    }
}

function darkenColorHex(color, percent) {
    let R = parseInt(color.substring(1, 3), 16);
    let G = parseInt(color.substring(3, 5), 16);
    let B = parseInt(color.substring(5, 7), 16);

    R = Math.floor(R * (100 - percent) / 100);
    G = Math.floor(G * (100 - percent) / 100);
    B = Math.floor(B * (100 - percent) / 100);

    return `#${R.toString(16).padStart(2, '0')}${G.toString(16).padStart(2, '0')}${B.toString(16).padStart(2, '0')}`;
}

// ========== Energy Plot Functions ==========

let energyPlotData = {
    energies: [],
    minEnergy: 0,
    maxEnergy: 0,
    hasEnergy: false
};

function extractEnergyData() {
    if (!molecularData || molecularData.length === 0) {
        energyPlotData.hasEnergy = false;
        return;
    }

    energyPlotData.energies = [];
    let hasAnyEnergy = false;

    for (let i = 0; i < molecularData.length; i++) {
        const mol = molecularData[i];
        if (mol.energy !== undefined && mol.energy !== null) {
            energyPlotData.energies.push(mol.energy);
            hasAnyEnergy = true;
        } else {
            energyPlotData.energies.push(null);
        }
    }

    energyPlotData.hasEnergy = hasAnyEnergy;

    if (hasAnyEnergy) {
        const validEnergies = energyPlotData.energies.filter(e => e !== null);
        energyPlotData.minEnergy = Math.min(...validEnergies);
        energyPlotData.maxEnergy = Math.max(...validEnergies);
    }
}

function drawEnergyPlot() {
    const canvas = document.getElementById('energy-plot-canvas');
    const container = document.getElementById('energy-plot-container');
    if (!canvas || !container) return;

    // Extract energy data if not done yet
    if (energyPlotData.energies.length !== molecularData.length) {
        extractEnergyData();
    }

    if (!energyPlotData.hasEnergy) {
        container.style.display = 'none';
        const checkbox = document.getElementById('show-energy-plot');
        if (checkbox) checkbox.checked = false;
        settings.showEnergyPlot = false;
        console.log('No energy data available');
        return;
    }

    const ctx = canvas.getContext('2d');
    const rect = container.getBoundingClientRect();

    // Set canvas size for sharp rendering
    const dpr = window.devicePixelRatio || 1;
    canvas.width = (rect.width - 20) * dpr;
    canvas.height = (rect.height - 20) * dpr;
    canvas.style.width = (rect.width - 20) + 'px';
    canvas.style.height = (rect.height - 20) + 'px';
    ctx.scale(dpr, dpr);

    const width = rect.width - 20;
    const height = rect.height - 20;
    const padding = { left: 50, right: 20, top: 15, bottom: 25 };
    const plotWidth = width - padding.left - padding.right;
    const plotHeight = height - padding.top - padding.bottom;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Draw background grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
        const y = padding.top + (plotHeight / 4) * i;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
    }

    // Calculate scale
    const energies = energyPlotData.energies;
    const n = energies.length;
    let minE = energyPlotData.minEnergy;
    let maxE = energyPlotData.maxEnergy;

    // Add some padding to range
    const range = maxE - minE || 1;
    minE -= range * 0.1;
    maxE += range * 0.1;

    // Draw energy line
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;

    for (let i = 0; i < n; i++) {
        if (energies[i] === null) continue;
        const x = padding.left + (i / (n - 1 || 1)) * plotWidth;
        const y = padding.top + plotHeight - ((energies[i] - minE) / (maxE - minE)) * plotHeight;

        if (!started) {
            ctx.moveTo(x, y);
            started = true;
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.stroke();

    // Draw data points
    ctx.fillStyle = '#3b82f6';
    for (let i = 0; i < n; i++) {
        if (energies[i] === null) continue;
        const x = padding.left + (i / (n - 1 || 1)) * plotWidth;
        const y = padding.top + plotHeight - ((energies[i] - minE) / (maxE - minE)) * plotHeight;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw current frame marker
    drawEnergyPlotMarker();

    // Draw axes labels
    ctx.fillStyle = '#9ca3af';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(maxE.toFixed(2), padding.left - 5, padding.top + 5);
    ctx.fillText(minE.toFixed(2), padding.left - 5, height - padding.bottom);

    ctx.textAlign = 'center';
    ctx.fillText('Frame', width / 2, height - 5);

    // Y-axis label
    ctx.save();
    ctx.translate(12, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Energy (eV)', 0, 0);
    ctx.restore();
}

function drawEnergyPlotMarker() {
    const canvas = document.getElementById('energy-plot-canvas');
    const container = document.getElementById('energy-plot-container');
    if (!canvas || !container || !energyPlotData.hasEnergy) return;

    const ctx = canvas.getContext('2d');
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    const width = rect.width - 20;
    const height = rect.height - 20;
    const padding = { left: 50, right: 20, top: 15, bottom: 25 };
    const plotWidth = width - padding.left - padding.right;
    const plotHeight = height - padding.top - padding.bottom;

    const energies = energyPlotData.energies;
    const n = energies.length;
    const frameIdx = animationState.currentFrame;

    if (n <= 1 || frameIdx < 0 || frameIdx >= n) return;

    // Draw current frame marker (vertical line)
    const x = padding.left + (frameIdx / (n - 1 || 1)) * plotWidth;

    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, padding.top);
    ctx.lineTo(x, height - padding.bottom);
    ctx.stroke();

    // Draw marker point if energy exists
    if (energies[frameIdx] !== null) {
        let minE = energyPlotData.minEnergy;
        let maxE = energyPlotData.maxEnergy;
        const range = maxE - minE || 1;
        minE -= range * 0.1;
        maxE += range * 0.1;

        const y = padding.top + plotHeight - ((energies[frameIdx] - minE) / (maxE - minE)) * plotHeight;

        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();

        // Show energy value
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(energies[frameIdx].toFixed(4) + ' eV', x, padding.top - 3);
    }
}

window.setMolecularData = setMolecularData;
window.removePeriodicity = removePeriodicity;

// PostMessage API for iframe embedding
window.addEventListener('message', function(event) {
    const msg = event.data;
    if (!msg || !msg.type) return;

    switch (msg.type) {
        case 'setData':
            if (msg.data) {
                setMolecularData(msg.data);
            }
            break;
        case 'setSettings':
            if (msg.settings) {
                Object.assign(settings, msg.settings);
                if (typeof updateFromSettings === 'function') {
                    updateFromSettings();
                }
            }
            break;
        case 'ready':
            if (event.source) {
                event.source.postMessage({ type: 'ready', viewer: 'molecular' }, '*');
            }
            break;
    }
});

// Notify parent that viewer is loaded
if (window.parent !== window) {
    window.parent.postMessage({ type: 'viewerLoaded', viewer: 'molecular' }, '*');
}
</script>
</body>
</html>